<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: active record | Fun On Rails]]></title>
  <link href="http://funonrails.com/categories/active-record/atom.xml" rel="self"/>
  <link href="http://funonrails.com/"/>
  <updated>2014-04-02T15:54:48+05:30</updated>
  <id>http://funonrails.com/</id>
  <author>
    <name><![CDATA[sandipransing]]></name>
    <email><![CDATA[sandip@funonrails.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Get models list inside rails app]]></title>
    <link href="http://funonrails.com/2012/01/get-models-used-in-rails-app/"/>
    <updated>2012-01-17T05:16:00+05:30</updated>
    <id>http://funonrails.com/2012/01/get-models-used-in-rails-app</id>
    <content type="html"><![CDATA[<p>How to get collection of models inside your application. Certainly there are many ways to do it.
Lets have a look at different ways starting from worst &ndash;</p>

<p>Get table names inside database and then iterating over to get model name
```ruby
@models = ActiveRecord::Base.connection.tables.collect{|t| t.underscore.singularize.camelize}</p>

<h1>=> [&ldquo;AdhearsionAudit&rdquo;, &ldquo;AudioLog&rdquo;, &ldquo;AuditDetail&rdquo;,&ldquo;TinyPrint&rdquo;, &ldquo;TinyVideo&rdquo;, &ldquo;UnknownCall&rdquo;, &ldquo;UserAudit&rdquo;, &ldquo;User&rdquo;]</h1>

<p>```</p>

<p>Select those with associated class
<code>ruby
@models.delete_if{|m| m.constantize rescue true}
</code></p>

<p>Load models dir
<code>ruby
@models = Dir['app/models/*.rb'].map {|f| File.basename(f, '.*').camelize.constantize.name }
</code></p>

<p>Select ActiveRecord::Base extended class only
<code>ruby
@models.reject!{|m| m.constantize.superclass != ActiveRecord::Base }
</code></p>

<p>Get Active Record subclasses
```ruby</p>

<h1>make sure relevant models are loaded otherwise</h1>

<h1>require them prior</h1>

<h1>Dir.glob(RAILS_ROOT + &lsquo;/app/models/*.rb&rsquo;).each { |file| require file }</h1>

<p>class A &lt; ActiveRecord::Base
end
class B &lt; A
end
ActiveRecord::Base.send(:subclasses).collect(&amp;:name)</p>

<h1>=> [&hellip;., A]</h1>

<p>```</p>

<p>How to get Inherited models too
```ruby
class A &lt; ActiveRecord::Base
end
class B &lt; A
end
ActiveRecord::Base.descendants.collect(&amp;:name)</p>

<h1>=> [&hellip;., A, B]</h1>

<p>```</p>

<p>Below is more elegant solution provide by <a href="http://stackoverflow.com/users/268/vincent-robert">Vincent-robert</a> over stack overflow which recursively looks for subsequent descendent&rsquo;s of class and gives you list from all over application
```ruby
class Class
  def extend?(klass)</p>

<pre><code>not superclass.nil? and ( superclass == klass or superclass.extend? klass )
</code></pre>

<p>  end
end</p>

<p>def models
  Module.constants.select do |constant_name|</p>

<pre><code>constant = eval constant_name
if not constant.nil? and constant.is_a? Class and constant.extend? ActiveRecord::Base
constant
end
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simplified Active Record Extensions]]></title>
    <link href="http://funonrails.com/2011/12/simplified-active-record-extensions/"/>
    <updated>2011-12-28T14:21:00+05:30</updated>
    <id>http://funonrails.com/2011/12/simplified-active-record-extensions</id>
    <content type="html"><![CDATA[<p>Below extensions to active record base simplifies its usage while coding.</p>

<p>```ruby</p>

<h1>config/initializers/core_extensions.rb</h1>

<p>class ActiveRecord::Base</p>

<p>  def self.pagination(options)</p>

<pre><code>paginate :per_page =&gt; options[:per_page] || per_page, :page =&gt; options[:page]
</code></pre>

<p>  end</p>

<p>  def self.options_for_select(opts={})</p>

<pre><code>opts[:name] ||= :name
opts[:attr] ||= :id
opts[:prompt] ||= 'Please Select'
all.collect{|c| [c.send(opts[:name].to_sym), c.send(opts[:attr].to_sym)]}.insert(0, [opts[:prompt], nil])
</code></pre>

<p>  end
end
```</p>

<p>Usage
```ruby
class Student&lt; ActiveRecord::Base
 #attributes #=> name, age
end</p>

<h2></h2>

<p>Student.pagination({:page => 10})
Student.pagination({:per_page => 2, :page => 2})
Student.options_for_select
Student.options_for_select({:prompt => &lsquo;Please select&rsquo;})
Student.options_for_select({:name => :age})
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best practices to use named scopes inside models]]></title>
    <link href="http://funonrails.com/2011/12/best-practices-to-use-named-scopes/"/>
    <updated>2011-12-22T18:50:00+05:30</updated>
    <id>http://funonrails.com/2011/12/best-practices-to-use-named-scopes</id>
    <content type="html"><![CDATA[<blockquote><p>Scopes are partial query conditions to database queries. scopes are always prefixed to class finders. There are several ways to use scopes inside rails models.</p></blockquote>

<p><strong>1.  Scope defined below gets loaded while class definition loads</strong>
<code>ruby
scope :active, where(:active =&gt; true)
scope :archived, where(:archived =&gt; true, :post_type =&gt; :general)
</code>
<strong>2.  Dynamic scopes needs to be always defined inside lambda</strong>
<code>ruby
scope :not_expired, lambda { where('expiry_date &lt;= ?', Date.today) }
</code>
<strong>3.  Combining scopes</strong>
<code>ruby
scope :visible, published.not_expired
</code>
<strong>4.  Passing parameters to scopes</strong>
```ruby</p>

<h1>avoid below</h1>

<p>scope :created_by_user, lambda {|user|
  where(&lsquo;user_id = ?&rsquo;, user)
}</p>

<h1>use this</h1>

<p>scope :created_by_user, lambda {|user|
  where(:user_id => user)
}
```</p>

<p><strong>5.  passing multiple parameters</strong>
```ruby</p>

<h1>avoid below</h1>

<p>scope :made_between, lambda{|from, to|
  where(&lsquo;created_date >= ? and created_date &lt;= ?&rsquo;, from, to)
}</p>

<h1>use this</h1>

<p>scope :made_between, lambda{|from, to|
  where(&lsquo;created_date >= :from and created_date &lt;= :to&rsquo;, :from => from, :to => to)
}
```</p>

<p><strong>6.  associations inside scope (joins and includes)</strong>
```ruby</p>

<h1>below will perform eager loading effective when rendering posts with comments</h1>

<p>scope :with_user_comments, lambda{|user|
  includes(:comments).where(&lsquo;comments.user_id = ?&rsquo;, user)
}</p>

<h1>faster</h1>

<h1>also can be done as post.comments.where(:user_id => user)</h1>

<p>scope :with_user_comments, lambda{|user|
  joins(:comments).where(&lsquo;comments.user_id = ?&rsquo;, user)
}
```</p>

<p>So, at last would suggest making use of symbols when there are multiple parameters to scopes and make maximum use of scopes rather than having where conditions everywhere :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Legacy database connections in rails]]></title>
    <link href="http://funonrails.com/2011/10/connecting-to-multiple-databases-in-rails/"/>
    <updated>2011-10-05T13:13:00+05:30</updated>
    <id>http://funonrails.com/2011/10/connecting-to-multiple-databases-in-rails</id>
    <content type="html"><![CDATA[<blockquote><p>While developing rails application we often come across situation where you wanted different rails models connecting different tables of different databases.</p></blockquote>

<p>Example: We are having ndnc model holding ndnc records associated with database ndnc.
Lets create ConnectionBase model that will connect to other databse &lsquo;ndnc&rsquo; and that will be extended from ActiveRecordBase and put that inside library files</p>

<p>```ruby</p>

<h1>lib/connection_base.rb</h1>

<p>class ConnectionBase &lt; ActiveRecord::Base</p>

<p>  establish_connection(</p>

<pre><code>:adapter =&gt; "postgresql",
:username=&gt; "sandip",
:password =&gt; "2121",
:database =&gt; "ndnc"
</code></pre>

<p>)
end
```</p>

<p>Wherever you wanted to connect to other database i.e. ndnc you can extend that particular model with ConnectionBase</p>

<p>```ruby
class Ndnc &lt; ConnectionBase</p>

<h1>connects to ndnc table of ndnc database</h1>

<p>end
```</p>

<p>Please make sure library files are loaded while server startup
```ruby</p>

<h1>vi config/application.rb</h1>

<p>config.autoload_paths += %W(#{config.root}/lib)
```
Done !
In cases where you want only one particular model connecting other database table, you can put connection setting itself in that model.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord::ReadOnlyRecord while updating object fetched by joins]]></title>
    <link href="http://funonrails.com/2010/02/activerecordreadonlyrecord-while/"/>
    <updated>2010-02-15T21:34:00+05:30</updated>
    <id>http://funonrails.com/2010/02/activerecordreadonlyrecord-while</id>
    <content type="html"><![CDATA[<h4>ActiveRecord find with join options retrieves object as readonly</h4>

<p><code>
station = Station.find( :first, :joins =&gt; :call, :conditions =&gt; ["customer_id = ? and date(insurance_expiry_date) = ?", customer.id, insurance_expiry_date ] )
</code>
Readonly object cannot modified and hence below line raises &ldquo;ActiveRecord::ReadOnlyRecord&rdquo; error.
<code>
station.update_attributes({ :customer_id =&gt; 12 })
</code>
If you have to write on read only object then you can pass following option to find query
<code>
:readonly =&gt; false
</code>
Now below find is permitted to do write on fetched object records.
<code>
station = Station.find( :first, :joins =&gt; :call, :conditions =&gt; ["customer_id = ? and date(insurance_expiry_date) = ?", customer.id, insurance_expiry_date ], :readonly =&gt; false )
</code></p>
]]></content>
  </entry>
  
</feed>
