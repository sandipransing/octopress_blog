<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bootstrap | Fun On Rails]]></title>
  <link href="http://funonrails.com/categories/bootstrap/atom.xml" rel="self"/>
  <link href="http://funonrails.com/"/>
  <updated>2014-03-11T17:27:38+05:30</updated>
  <id>http://funonrails.com/</id>
  <author>
    <name><![CDATA[sandipransing]]></name>
    <email><![CDATA[sandip@funonrails.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[twitter-bootstrap form builder for rails]]></title>
    <link href="http://funonrails.com/2012/01/twitter-bootstrap-form-builder-for-rails/"/>
    <updated>2012-01-17T05:39:00+05:30</updated>
    <id>http://funonrails.com/2012/01/twitter-bootstrap-form-builder-for-rails</id>
    <content type="html"><![CDATA[<p><a href="twitter.github.com/bootstrap/">twitter-bootstrap</a> is pluggable css suit provided by twitter.
To know more about how to get started on it click <a href="http://www.funonrails.com/2011/11/rails-311-haml-sass-jquery-coffee-rails">here</a>.</p>

<p>Below post will help you out in getting started bootstrap css with rails app. One need to add below files to helpers directory.
MainForm can be used as base version of form builder and can be overriden for its subsequent use inside other custom form builders.</p>

<ol>
<li>Main Form
```ruby

<h1>app/helpers/main_form.rb</h1>

<p>class MainForm &lt; ActionView::Helpers::FormBuilder # NestedForm::Builder
CSS = {
 :label => &lsquo;label-control&rsquo;,
 :hint => &lsquo;hint&rsquo;,
 :hint_ptr => &lsquo;hint-pointer&rsquo;,
 :error => &lsquo;help-inline&rsquo;,
 :field_error => &lsquo;error&rsquo;,
 :main_class => &lsquo;clearfix&rsquo;
}</p></li>
</ol>


<p>  FIELDS = %w(radio_button check_box text_field text_area password_field select file_field collection_select email_field date_select)</p>

<p>  def main_class(error=nil)</p>

<pre><code>return CSS[:main_class] unless error
[CSS[:main_class], CSS[:field_error]].join(' ')
</code></pre>

<p>  end</p>

<p>  def required(name)</p>

<pre><code>object.class.validators_on(name).map(&amp;:class).include?(ActiveModel::Validations::PresenceValidator) rescue nil
</code></pre>

<p>  end</p>

<p>  def cancel(options={})</p>

<pre><code>link = options.fetch(:return, "/")
@template.content_tag(:a, "Cancel", :href =&gt; link, :class =&gt; "btn_form button np_cancel_btn #{options[:class]}")
</code></pre>

<p>  end</p>

<p>  def submit(value=&ldquo;Save&rdquo;, options={})</p>

<pre><code>options[:class] = "send_form_btn #{options[:class]}"
super
</code></pre>

<p>  end</p>

<p>  def label_class</p>

<pre><code>{:class =&gt; CSS[:label]}
</code></pre>

<p>  end</p>

<p>  def label_tag(attribute, arg)</p>

<pre><code># Incase its a mandatory field, the '*' is added to the field.
txt = arg[:label] &amp;&amp; arg[:label].to_s || attribute.to_s.titleize
txt&lt;&lt; '*' if(arg[:required] || required(attribute)) &amp;&amp; arg[:required] != false
label(attribute, txt, label_class)
</code></pre>

<p>  end</p>

<p>  def error_tag(method_name, attribute)</p>

<pre><code>errs = field_error(method_name, attribute)
@template.content_tag(:span, errs.first, :class =&gt; CSS[:error]) if errs.present?
</code></pre>

<p>  end</p>

<p>  def field_error(method_name, attribute)</p>

<pre><code>return if @object &amp;&amp; @object.errors.blank?
return @object.errors[attribute] if method_name != 'file_field'
@object.errors["#{attribute.to_s}_file_name"] | @object.errors["#{attribute.to_s}_file_size"] | @object.errors["#{attribute.to_s}_content_type"]
</code></pre>

<p>  end</p>

<p>  def hint_tag(txt)</p>

<pre><code>hintPtr = @template.content_tag(:span, '', :class =&gt; CSS[:hint_ptr])
hintT = @template.content_tag(:span, txt + hintPtr, {:class =&gt; CSS[:hint]}, false) 
</code></pre>

<p>  end</p>

<p>  def spinner_tag</p>

<pre><code>@template.image_tag('spinner.gif', :class =&gt; :spinner,:id =&gt; :spinner) 
</code></pre>

<p>  end
end<br/>
```</p>

<!--more-->


<p>ZeroForm is custom form builder which is inherited from <code>main_form</code> and its going to be actually used inside forms.
Feel free to make custom form related changes inside this</p>

<p>```ruby</p>

<h1>app/helpers/zero_form.rb</h1>

<p>class ZeroForm &lt; MainForm
  # Overridden label_class here as we dont need class to be applied
  def label_class</p>

<pre><code>{}
</code></pre>

<p>  end</p>

<p>  def self.create_tagged_field(method_name)</p>

<pre><code>define_method(method_name) do |attribute, *args|
  arg = args.last &amp;&amp; args.last.is_a?(Hash) &amp;&amp; args.last || {}

  # Bypass form-builder and do your own custom stuff!
  return super(attribute, *args) if arg[:skip] &amp;&amp; args.last.delete(:skip)

  errT = error_tag(method_name, attribute)
  labelT = label_tag(attribute, arg)

  mainT = super(attribute, *args)
  baseT = @template.content_tag(:div, mainT + errT)

  hintT = hint_tag(arg[:hint]) if arg[:hint]
  spinnerT = spinner_tag if arg[:spinner]

  allT = labelT + baseT + spinnerT + hintT
  @template.content_tag(:div, allT, :class =&gt; main_class(errT))
end
</code></pre>

<p>  end</p>

<p>  FIELDS.each do |name|</p>

<pre><code>create_tagged_field(name)
</code></pre>

<p>  end
end
```
In order to use Nested Forms you need to extend MainForm with NestedForm Builder</p>

<p><strong>Integrate NestedForm with FormBuilder</strong></p>

<p><code>ruby
class MainForm &lt; NestedForm::Builder
end
</code>
<strong>View Form</strong>
<code>haml
= form_for @address ||= Address.new, :builder =&gt; ZeroForm do |f|
  = f.text_field :street_address
  = f.text_area :detail_address, :rows =&gt; 2
  = f.text_field :city
  = f.select :state, %w(US IN AUS UK UKRAINE)
  = f.submit 'Save &amp; Continue', :class =&gt; 'btn primary'
  = link_to 'Skip Â»', '#'
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[twitter bootstrap paginate and rails 3]]></title>
    <link href="http://funonrails.com/2011/12/twitter-bootstrap-paginate-and-rails-3/"/>
    <updated>2011-12-28T14:06:00+05:30</updated>
    <id>http://funonrails.com/2011/12/twitter-bootstrap-paginate-and-rails-3</id>
    <content type="html"><![CDATA[<p>Twitter bootstrap is css toolkit for rapid front-end UI development.
To get will-paginate working with bootstrap css we need to override default pagination link renderer.</p>

<p>Using Bootstrap-sass for rails 3
```</p>

<h1>Gemfile</h1>

<p>gem &lsquo;sass-rails&rsquo;
gem &lsquo;bootstrap-sass&rsquo;
```</p>

<p>```sass</p>

<h1>app/assets/stylesheets/application.css.sass</h1>

<p>// Place all the styles related to the home controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: <a href="http://sass-lang.com/">http://sass-lang.com/</a>
//= require bootstrap
```</p>

<p>Add WillPaginate LinkRenderer to intitializer
```ruby</p>

<h1>config/initializers/will_paginate.rb</h1>

<p>module WillPaginate
  module ActiveRecord</p>

<pre><code>module RelationMethods
  alias_method :per, :per_page
  alias_method :num_pages, :total_pages
  alias_method :total_count, :count
end
</code></pre>

<p>  end</p>

<p>  module ActionView</p>

<pre><code>def will_paginate(collection = nil, options = {})
  options[:inner_window] ||= 0
  options[:outer_window] ||= 0
  options[:class] ||= 'pagination pull-left'

  options[:renderer] ||= BootstrapLinkRenderer
  super.try :html_safe
end

class BootstrapLinkRenderer &lt; LinkRenderer
  protected

  def html_container(html)
    tag :div, tag(:ul, html), container_attributes
  end

  def page_number(page)
    tag :li, link(page, page, :rel =&gt; rel_value(page)), :class =&gt; ('active' if page == current_page)
  end

  def previous_or_next_page(page, text, classname)
    tag :li, link(text, page || 'javascript:void(0)'), :class =&gt; [classname[0..3], classname, ('disabled' unless page)].join(' ')
  end

  def gap
    tag :li, link(super, 'javascript:void(0)'), :class =&gt; 'disabled'
  end

end
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
