<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails 3 | Fun On Rails]]></title>
  <link href="http://sandipransing.github.io/blog/categories/rails-3/atom.xml" rel="self"/>
  <link href="http://sandipransing.github.io/"/>
  <updated>2014-02-09T20:36:37+05:30</updated>
  <id>http://sandipransing.github.io/</id>
  <author>
    <name><![CDATA[sandipransing]]></name>
    <email><![CDATA[sandip@funonrails.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dynamic & bounded parameters and named routes]]></title>
    <link href="http://sandipransing.github.io/2012/01/dynamic-bounded-parameters-and-named"/>
    <updated>2012-01-31T02:43:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/dynamic-bounded-parameters-and-named</id>
    <content type="html"><![CDATA[<div class='post'>
Rails routes can be customized as your own routes with parameters but first you should understand how routes behaves. <br/> <b>Adding dynamic parameters to routes </b> <br/>Here exact parameters are matched to route and presence of each parameter is mandatory in order to construct urls. blank parameter will raise RoutingError exception. <br/>Exact matched named route declared as -  <code>  match ':a/:b/:c', :to => 'home#index', :as => :q </code> now go to the rails console - <code> ruby-1.9.3-head :005 > app.q_url(:a, :b, :c)   => "http://www.example.com/a/b/c"        ruby-1.9.3-head :006 > app.q_url(:a, :b, '')   ActionController::RoutingError: No route matches {:controller=>"home", :a=>:a, :b=>:b, :c=>""} </code><b>Bound parameters to named routes</b><br/>If you are too sure that certain parameter can be blank then you can define it as optional parameter inside route -  <br/><code> match ':a/:b(/:c)', :to => 'home#index', :as => :q </code><b>rails console</b><code> ruby-1.9.3-head :010 > app.q_url(:a, :b, '')   => "http://www.example.com/a/b?c="   ruby-1.9.3-head :011 > app.q_url(:a, :b)   => "http://www.example.com/a/b" </code></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[csv file import / export in rails 3]]></title>
    <link href="http://sandipransing.github.io/2012/01/csv-file-importexport-in-rails-3"/>
    <updated>2012-01-27T14:28:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/csv-file-importexport-in-rails-3</id>
    <content type="html"><![CDATA[<div class='post'>
CSV (comma separated values) files are frequently used to import/export data. <br/>In rails 3, FasterCSV comes as default and below is the way to upload csv files inside rails applications. The code below will also show you how to generate csv in memory, parse on csv data, skip header, iterate over records, save records inside db, export upload error file and many more. <br/>First, View to upload file <br/><code>= form_tag upload_url, :multipart => true do   %label{:for => "file"} File to Upload   = file_field_tag "file"   = submit_tag </code>Assume upload_url maps to import action of customers controller <br/>Controller code <br/><code>class CustomersController < ApplicationController     [...]    def import     if request.post? && params[:file].present?       infile = params[:file].read       n, errs = 0, []        CSV.parse(infile) do |row|         n += 1         # SKIP: header i.e. first row OR blank row         next if n == 1 or row.join.blank?         # build_from_csv method will map customer attributes &          # build new customer record         customer = Customer.build_from_csv(row)         # Save upon valid          # otherwise collect error records to export         if customer.valid?           customer.save         else           errs << row         end       end       # Export Error file for later upload upon correction       if errs.any?         errFile ="errors_#{Date.today.strftime('%d%b%y')}.csv"         errs.insert(0, Customer.csv_header)         errCSV = CSV.generate do |csv|           errs.each {|row| csv << row}         end         send_data errCSV,           :type => 'text/csv; charset=iso-8859-1; header=present',           :disposition => "attachment; filename=#{errFile}.csv"       else         flash[:notice] = I18n.t('customer.import.success')         redirect_to import_url #GET       end     end   end   [...] end </code>Customer model <br/><code>class Customer < ActiveRecord::Base   scope :active, where(:active => true)   scope :latest, order('created_at desc')      def self.csv_header     "First Name,Last Name,Email,Phone,Mobile, Address, FAX, City".split(',')   end      def self.build_from_csv(row)     # find existing customer from email or create new     cust = find_or_initialize_by_email(row[2])     cust.attributes ={:first_name => row[0],       :last_name => row[1],       :email => row[3],       :phone => row[4],       :mobile => row[5],       :address => row[6],       :fax => row[7],       :city => row[8]}     return cust   end      def to_csv     [first_name, last_name, email, phone, mobile, address, fax, city]   end end </code><br/>Export customer records in CSV format<br/>Below code loads customer records from database then generate csv_data inside memory and  exports data to browser using send_data method.<br/>Note: As we are not writing on file system hence code can easily work heroku. <code>  def export     # CRITERIA : to select customer records     #=> Customer.active.latest.limit(100)     custs = Customer.limit(10)     filename ="customers_#{Date.today.strftime('%d%b%y')}"     csv_data = FasterCSV.generate do |csv|       csv << Customer.csv_header       custs.each do |c|          csv << c.to_csv       end      end      send_data csv_data,       :type => 'text/csv; charset=iso-8859-1; header=present',       :disposition => "attachment; filename=#{filename}.csv"   end  </code></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mongoid array field and rails form]]></title>
    <link href="http://sandipransing.github.io/2012/01/mongoid-array-field-and-rails-form"/>
    <updated>2012-01-19T23:59:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/mongoid-array-field-and-rails-form</id>
    <content type="html"><![CDATA[<div class='post'>
mongoid document supports array as field. array field in mongoid document is a ruby array but its quite complex to manage array field in rails forms.<br/>After lot of google and reading comments from stack-overflow at last i felt helpless. Finally after doing research on rails form helper object(form_for, fields_for) am pleased to get it working as expected :)<br/>In below example, product can have multiple categories<br/><code>class Product   CATEGORIES = %w(Apparel Media Software Sports Agri Education)   include Mongoid::Document   field :name, :type => String   field :categories, :type => Array end </code>Here is form code <br/><code>= form_for(@product) do |f|   = f.text_field :name   - Product::CATEGORIES.each do |category|     = f.check_box :categories, :name => "product[categories][]", category </code><br/>Here is products controller code <br/><code>class ProductsController < ApplicationController   before_filter :load_product, :only => [:new, :create]      [...]      # We don't need new action to be defined      def create     @product.attributes = params[:product]     # Here we need to reject blank categories     @product.categories.reject!(&:blank?)     if @product.save       flash[:notice] = I18n.t('product.create.success')       redirect_to(:action => :index)     else       render :action => :new     end   end      [...]      private   def load_product     @product = Product.new   end end </code></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[twitter-bootstrap form builder for rails]]></title>
    <link href="http://sandipransing.github.io/2012/01/twitter-bootstrap-form-builder-for"/>
    <updated>2012-01-17T05:39:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/twitter-bootstrap-form-builder-for</id>
    <content type="html"><![CDATA[<div class='post'>
<a href="http://twitter.github.com/bootstrap/">twitter-bootstrap</a> is pluggable css suit provided by twitter. <br/>To know more about how to get started on it <a href="http://www.funonrails.com/2011/11/rails-311-haml-sass-jquery-coffee-rails.html">click here</a><br/>Below post will help you out in getting started bootstrap css with rails app. One need to add below files to helpers directory. MainForm can be used as base version of form builder and can be overriden for its subsequent use inside other custom form builders. <br/><b>1. MainForm </b> <br/><code># app/helpers/main_form.rb  class MainForm < ActionView::Helpers::FormBuilder # NestedForm::Builder   CSS = {     :label => 'label-control',     :hint => 'hint',     :hint_ptr => 'hint-pointer',     :error => 'help-inline',     :field_error => 'error',     :main_class => 'clearfix'   }    FIELDS = %w(radio_button check_box text_field text_area password_field select file_field collection_select email_field date_select)      def main_class(error=nil)     return CSS[:main_class] unless error     [CSS[:main_class], CSS[:field_error]].join(' ')   end    def required(name)     object.class.validators_on(name).map(&:class).include?(ActiveModel::Validations::PresenceValidator) rescue nil   end    def cancel(options={})     link = options.fetch(:return, "/")     @template.content_tag(:a, "Cancel", :href => link, :class => "btn_form button np_cancel_btn #{options[:class]}")   end    def submit(value="Save", options={})     options[:class] = "send_form_btn #{options[:class]}"     super   end    def label_class     {:class => CSS[:label]}   end    def label_tag(attribute, arg)     # Incase its a mandatory field, the '*' is added to the field.     txt = arg[:label] && arg[:label].to_s || attribute.to_s.titleize     txt<< '*' if(arg[:required] || required(attribute)) && arg[:required] != false     label(attribute, txt, label_class)   end    def error_tag(method_name, attribute)     errs = field_error(method_name, attribute)     @template.content_tag(:span, errs.first, :class => CSS[:error]) if errs.present?   end    def field_error(method_name, attribute)     return if @object && @object.errors.blank?     return @object.errors[attribute] if method_name != 'file_field'     @object.errors["#{attribute.to_s}_file_name"] | @object.errors["#{attribute.to_s}_file_size"] | @object.errors["#{attribute.to_s}_content_type"]   end    def hint_tag(txt)     hintPtr = @template.content_tag(:span, '', :class => CSS[:hint_ptr])     hintT = @template.content_tag(:span, txt + hintPtr, {:class => CSS[:hint]}, false)    end     def spinner_tag     @template.image_tag('spinner.gif', :class => :spinner,:id => :spinner)    end end   </code>ZeroForm is custom form builder which is inherited from main_form and its going to be actually used inside forms. Feel free to make custom form related changes inside this<br/><b>ZeroForm</b><br/><code>cat app/helpers/zero_form.rb  class ZeroForm < MainForm   # Overridden label_class here as we dont need class to be applied   def label_class     {}   end    def self.create_tagged_field(method_name)     define_method(method_name) do |attribute, *args|       arg = args.last && args.last.is_a?(Hash) && args.last || {}        # Bypass form-builder and do your own custom stuff!       return super(attribute, *args) if arg[:skip] && args.last.delete(:skip)        errT = error_tag(method_name, attribute)       labelT = label_tag(attribute, arg)        mainT = super(attribute, *args)       baseT = @template.content_tag(:div, mainT + errT)        hintT = hint_tag(arg[:hint]) if arg[:hint]       spinnerT = spinner_tag if arg[:spinner]        allT = labelT + baseT + spinnerT + hintT       @template.content_tag(:div, allT, :class => main_class(errT))     end   end    FIELDS.each do |name|     create_tagged_field(name)   end end </code><br/>In order to use Nested Forms you need to extend MainForm with NestedForm Builder<br/><b>Integrate NestedForm with FormBuilder</b><code>class MainForm < NestedForm::Builder end </code><b>View Form</b><br/><code>= form_for @address ||= Address.new, :builder => ZeroForm do |f|   = f.text_field :street_address   = f.text_area :detail_address, :rows => 2   = f.text_field :city   = f.select :state, %w(US IN AUS UK UKRAINE)   = f.submit 'Save & Continue', :class => 'btn primary'   = link_to 'Skip &raquo', '#' </code><br/>To know more on twitter-bootstrap pagination in rails <a herf="http://www.funonrails.com/2011/12/twitter-bootstrap-paginate-and-rails-3.html">click here</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get models list inside rails app]]></title>
    <link href="http://sandipransing.github.io/2012/01/get-models-list-inside-rails-app"/>
    <updated>2012-01-17T05:16:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/get-models-list-inside-rails-app</id>
    <content type="html"><![CDATA[<div class='post'>
How to get collection of models inside your application. Certainly there are many ways to do it.<br/>Lets have a look at different ways starting from worst - <br/><b> Get table names inside database and then iterating over to get model name</b><code>@models = ActiveRecord::Base.connection.tables.collect{|t| t.underscore.singularize.camelize}  #=> ["AdhearsionAudit", "AudioLog", "AuditDetail","TinyPrint", "TinyVideo", "UnknownCall", "UserAudit", "User"] </code><br/><b>Select those with associated class</b><br/><code>@models.delete_if{|m| m.constantize rescue true} </code><br/><b>Load models dir</b><br/><code>@models = Dir['app/models/*.rb'].map {|f| File.basename(f, '.*').camelize.constantize.name } </code><b>Select ActiveRecord::Base extended class only</b><code>@models.reject!{|m| m.constantize.superclass != ActiveRecord::Base } </code><b>Get Active Record subclasses</b><br/><code># make sure relevant models are loaded otherwise # require them prior # Dir.glob(RAILS_ROOT + '/app/models/*.rb').each { |file| require file } class A < ActiveRecord::Base end class B < A end ActiveRecord::Base.send(:subclasses).collect(&:name) #=> [...., A] </code><b>How to get Inherited models too</b> <br/><code>class A < ActiveRecord::Base end class B < A end ActiveRecord::Base.descendants.collect(&:name) #=> [...., A, B] </code> Below is more elegant solution provide by <a href="http://stackoverflow.com/users/268/vincent-robert">Vincent-robert</a> over stack overflow which recursively looks for subsequent descendent's of class and gives you list from all over application<br/><code>class Class   def extend?(klass)     not superclass.nil? and ( superclass == klass or superclass.extend? klass )   end end  def models    Module.constants.select do |constant_name|     constant = eval constant_name     if not constant.nil? and constant.is_a? Class and constant.extend? ActiveRecord::Base     constant     end   end end </code></div>

]]></content>
  </entry>
  
</feed>
