<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: form-builder | Fun On Rails]]></title>
  <link href="http://sandipransing.github.io/blog/categories/form-builder/atom.xml" rel="self"/>
  <link href="http://sandipransing.github.io/"/>
  <updated>2014-02-09T23:18:57+05:30</updated>
  <id>http://sandipransing.github.io/</id>
  <author>
    <name><![CDATA[sandipransing]]></name>
    <email><![CDATA[sandip@funonrails.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[twitter-bootstrap form builder for rails]]></title>
    <link href="http://sandipransing.github.io/2012/01/twitter-bootstrap-form-builder-for/"/>
    <updated>2012-01-17T05:39:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/01/twitter-bootstrap-form-builder-for</id>
    <content type="html"><![CDATA[<div class='post'>
<a href="http://twitter.github.com/bootstrap/">twitter-bootstrap</a> is pluggable css suit provided by twitter. <br/>To know more about how to get started on it <a href="http://www.funonrails.com/2011/11/rails-311-haml-sass-jquery-coffee-rails.html">click here</a><br/>Below post will help you out in getting started bootstrap css with rails app. One need to add below files to helpers directory. MainForm can be used as base version of form builder and can be overriden for its subsequent use inside other custom form builders. <br/><b>1. MainForm </b> <br/><pre class=ruby># app/helpers/main_form.rb  class MainForm < ActionView::Helpers::FormBuilder # NestedForm::Builder   CSS = {     :label => 'label-control',     :hint => 'hint',     :hint_ptr => 'hint-pointer',     :error => 'help-inline',     :field_error => 'error',     :main_class => 'clearfix'   }    FIELDS = %w(radio_button check_box text_field text_area password_field select file_field collection_select email_field date_select)      def main_class(error=nil)     return CSS[:main_class] unless error     [CSS[:main_class], CSS[:field_error]].join(' ')   end    def required(name)     object.class.validators_on(name).map(&:class).include?(ActiveModel::Validations::PresenceValidator) rescue nil   end    def cancel(options={})     link = options.fetch(:return, "/")     @template.content_tag(:a, "Cancel", :href => link, :class => "btn_form button np_cancel_btn #{options[:class]}")   end    def submit(value="Save", options={})     options[:class] = "send_form_btn #{options[:class]}"     super   end    def label_class     {:class => CSS[:label]}   end    def label_tag(attribute, arg)     # Incase its a mandatory field, the '*' is added to the field.     txt = arg[:label] && arg[:label].to_s || attribute.to_s.titleize     txt<< '*' if(arg[:required] || required(attribute)) && arg[:required] != false     label(attribute, txt, label_class)   end    def error_tag(method_name, attribute)     errs = field_error(method_name, attribute)     @template.content_tag(:span, errs.first, :class => CSS[:error]) if errs.present?   end    def field_error(method_name, attribute)     return if @object && @object.errors.blank?     return @object.errors[attribute] if method_name != 'file_field'     @object.errors["#{attribute.to_s}_file_name"] | @object.errors["#{attribute.to_s}_file_size"] | @object.errors["#{attribute.to_s}_content_type"]   end    def hint_tag(txt)     hintPtr = @template.content_tag(:span, '', :class => CSS[:hint_ptr])     hintT = @template.content_tag(:span, txt + hintPtr, {:class => CSS[:hint]}, false)    end     def spinner_tag     @template.image_tag('spinner.gif', :class => :spinner,:id => :spinner)    end end   </pre>ZeroForm is custom form builder which is inherited from main_form and its going to be actually used inside forms. Feel free to make custom form related changes inside this<br/><b>ZeroForm</b><br/><pre class=ruby>cat app/helpers/zero_form.rb  class ZeroForm < MainForm   # Overridden label_class here as we dont need class to be applied   def label_class     {}   end    def self.create_tagged_field(method_name)     define_method(method_name) do |attribute, *args|       arg = args.last && args.last.is_a?(Hash) && args.last || {}        # Bypass form-builder and do your own custom stuff!       return super(attribute, *args) if arg[:skip] && args.last.delete(:skip)        errT = error_tag(method_name, attribute)       labelT = label_tag(attribute, arg)        mainT = super(attribute, *args)       baseT = @template.content_tag(:div, mainT + errT)        hintT = hint_tag(arg[:hint]) if arg[:hint]       spinnerT = spinner_tag if arg[:spinner]        allT = labelT + baseT + spinnerT + hintT       @template.content_tag(:div, allT, :class => main_class(errT))     end   end    FIELDS.each do |name|     create_tagged_field(name)   end end </pre><br/>In order to use Nested Forms you need to extend MainForm with NestedForm Builder<br/><b>Integrate NestedForm with FormBuilder</b><pre class=ruby>class MainForm < NestedForm::Builder end </pre><b>View Form</b><br/><pre class=ruby>= form_for @address ||= Address.new, :builder => ZeroForm do |f|   = f.text_field :street_address   = f.text_area :detail_address, :rows => 2   = f.text_field :city   = f.select :state, %w(US IN AUS UK UKRAINE)   = f.submit 'Save & Continue', :class => 'btn primary'   = link_to 'Skip &raquo', '#' </pre><br/>To know more on twitter-bootstrap pagination in rails <a herf="http://www.funonrails.com/2011/12/twitter-bootstrap-paginate-and-rails-3.html">click here</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Customizing rails default form builder]]></title>
    <link href="http://sandipransing.github.io/2011/12/using-formbuilder-in-rails/"/>
    <updated>2011-12-29T01:29:00+05:30</updated>
    <id>http://sandipransing.github.io/2011/12/using-formbuilder-in-rails</id>
    <content type="html"><![CDATA[<div class='post'>
Customizing default rails form builder to adopt for labels, input fields, errors, hints, etc. in order to build forms just in minutes <br/><br/><pre class=ruby># app/helpers/app_form_builder.rb class AppFormBuilder < ActionView::Helpers::FormBuilder      HELPERS = %w[check_box text_field text_area password_field select date_select datetime_select file_field collection_select state_select label calendar_date_select]   def self.create_tagged_field(method_name)     define_method(method_name) do |name, *args|       errs = object.errors.on(name.to_sym) if object && object.errors        # initialize some local variables       if args.last.is_a?(Hash)         label = args.last.delete(:label)         suffix = args.last.delete(:suffix)         klass = args.last.delete(:class)         req = args.last.delete(:required)       end       label = 'none' if method_name == 'hidden_field'        label ||= name.to_s.titleize       label = nil if label == 'none'        klass = klass ? [klass] : []       # Custom class if it exists       if method_name =~ /text_field|check_box|select/         klass << method_name       end       klass << 'f' #A default selector       klass << 'error' if errs.present?       klass = klass.join(' ')        # Required Field Notations       if req == 'all' || (req == 'new' && object.new_record?)         label << @template.content_tag(:span, :*, :class => :req)       end        suffix = @template.content_tag(:label, suffix) if suffix.present?       label = @template.content_tag(:label, label) if label.present?       errs = @template.content_tag(:span, errs.to_s, :class => :message) if errs.present?       reverse = true if method_name == 'check_box'       if reverse         content = "#{super} #{suffix} #{label} #{errs}"       else         content = "#{label} #{super} #{suffix} #{errs}"       end        @template.content_tag(:div, content, :class => klass)     end   end    HELPERS.each do |name|     create_tagged_field(name)   end end </pre></div>

]]></content>
  </entry>
  
</feed>
