<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blocks | Fun On Rails]]></title>
  <link href="http://sandipransing.github.io/blog/categories/blocks/atom.xml" rel="self"/>
  <link href="http://sandipransing.github.io/"/>
  <updated>2014-02-09T23:18:57+05:30</updated>
  <id>http://sandipransing.github.io/</id>
  <author>
    <name><![CDATA[sandipransing]]></name>
    <email><![CDATA[sandip@funonrails.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby enumerable & to_proc (ampersond & symbol shortcut)]]></title>
    <link href="http://sandipransing.github.io/2012/02/ruby-enumerable-toproc-ampersond-colon/"/>
    <updated>2012-02-23T02:09:00+05:30</updated>
    <id>http://sandipransing.github.io/2012/02/ruby-enumerable-toproc-ampersond-colon</id>
    <content type="html"><![CDATA[<div class='post'>
Basically Enumerable mixin gives collection classes a variety of traverse, search, sort methods.<br/> <b>understanding ruby blocks i.e. proc </b><br/>blocks are statements of code written in ruby. one can take them as similar to c language macro's<br/> <b>Different ways to define blocks</b><br/><pre class=ruby>a = proc do   puts "hello" end a.call #=> hello  b = lambda do |u|   puts "hello #{u}" end b.call('sandip')#=> hello sandip  c = proc {|user| puts user } c.call('sandip') #=> sandip </pre> <b>Passing block to enumerator </b><br/>Lets assume we have collection array of strings and we want to print it<br/> <pre class=ruby> a = ['hi', 'sandip', 'how', 'you', 'doing', '?'] => ["hi", "sandip", "how", "you", "doing", "?"]  a.each {|w| puts w }  q = proc {|w| puts w } => #<Proc:0x00007f9d2be13140@(irb):89> a.each(&q) #=>hi sandip how you doing ?  a.map{|r| q.call(r)} #=>hi sandip how you doing ? </pre>  <b>Understanding symbol#to_proc </b><br/>Symbol has method to_proc which converts symbol to block where symbol is taken as method to be executed on first argument of proc<br/><b>How to_proc got implemented inside Symbol class</b><pre class=ruby>class Symbol   def to_proc     Proc.new { |*args| args.shift.__send__(self, *args) }   end end </pre>Lets have some examples <br/><pre class=ruby>v = :even?.to_proc # equivalent to proc {|a| a.even?} #=> #<Proc:0x00007f9d2bddcb90@(irb):97> q = [1, 2, 3, 5, 67]  q.map(&v) => [false, true, false, false, false] </pre> <b>Is there any shortcut?</b><br/>Yes, there is shortcut to have block passed to enumerators on the fly using ampersand followed by colon (i.e. symbol)<br/> <pre class=ruby>q = [1, 2, 3, 5, 67]  q.map(&:even?) <=> q.map(&:even?.to_proc)  q.map(&:even?.to_proc) #=> [false, true, false, false, false]  q.map(&:even?) #=> [false, true, false, false, false] </pre> <b>Some handy examples </b><br/><pre class=ruby>[1, 2, 3, 5, 67].inject(&:+) #=> 78 [1, 2, 3, 5, 67].inject(:+) #=> 78 [1, 2, 3, 5, 67].any?(&:even?) #=> true [1, 2, 3, 5, 67].detect(&:even?) #=> 2 ['ruby', 'on', 'rails'].map(&:upcase) #=> ["RUBY", "ON", "RAILS"] </pre></div>

]]></content>
  </entry>
  
</feed>
